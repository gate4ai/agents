# Стратегия Тестирования Проекта

Этот документ описывает подход к тестированию, принятый в проекте, перечисляет существующие тесты и определяет области, требующие дополнительного покрытия.

## 1. Текущая Стратегия Тестирования

Проект использует фреймворк **Vitest** для автоматизированного тестирования. Тесты разделены на два основных типа: **Unit-тесты** и **Интеграционные тесты**. Линтинг и запуск всех тестов являются обязательной частью CI/CD процесса, настроенного в `.github/workflows/ci.yml`.

### Инфраструктура Тестирования

- **Изолированная База Данных**: Для всех тестов используется отдельная, изолированная база данных SQLite, которая создается в памяти (`:memory:`) перед запуском тестов и уничтожается после их завершения. Это гарантирует, что тесты не влияют на данные разработки и выполняются в чистом окружении. Конфигурация находится в `test/test-db.ts` и `test/unit-setup.ts`.
- **Мокирование Внешних Сервисов**:
  - На уровне **Unit-тестов** внешние зависимости (например, `telegramService`, `AIManager`) мокируются с помощью `vi.mock`. Это позволяет тестировать бизнес-логику сервисов в полной изоляции.
  - На уровне **Интеграционных тестов** используется `supertest` для эмуляции реальных HTTP-запросов к API-эндпоинтам. Внешние API, такие как Telegram и OpenAI, мокируются с помощью **Mock Service Worker (MSW)**, что позволяет проверять взаимодействие компонентов без реальных сетевых вызовов.
- **Конфигурация**: `useRuntimeConfig` мокируется для предоставления стабильной конфигурации во время тестов.

### Существующие Тесты

#### Юнит-тесты (`test/unit/`)

Эти тесты проверяют корректность работы отдельных модулей (сервисов) в изоляции.

- `authService.spec.ts`: Проверяет логику `findOrCreateUser` — создание нового пользователя и поиск существующего.
- `botUserService.spec.ts`: Тестирует все функции для управления связями "пользователь-бот", включая получение бота по токену, установку/получение кастомных промптов.
- `sessionService.spec.ts`: Тестирует управление сессиями, включая создание, обновление истории диалога, установку состояний (`state`) и обработку некорректных данных (например, поврежденный JSON в истории).
- `botsCommandHandler.spec.ts`: Проверяет логику команды `/bots`, включая случаи, когда пользователь не найден, список ботов пуст, а также корректное форматирование ответа для ботов с кастомными и стандартными промптами.
- `cancelCommandHandler.spec.ts`: Проверяет, что команда `/cancel` корректно сбрасывает состояние сессии в `idle`.
- `webhook.spec.ts` (Handler Tests): Тестирует логику отдельных обработчиков команд (`handleStartCommand`, `handleSetPromptCommand`) и обработчика текстовых сообщений (`handleTextMessage`), проверяя их взаимодействие с базой данных и сервисами.
- `ai/openai.provider.spec.ts`: Тестирует OpenAI провайдер, включая генерацию текста и транскрипцию аудио.
- `ai/gemini.provider.spec.ts`: Тестирует Gemini провайдер, включая генерацию текста и транскрипцию через Google Cloud Speech.
- `telegramService.spec.ts`: Тестирует все функции Telegram сервиса, включая новые `getFileInfo` и `downloadFile`.
- `voiceHandler.spec.ts`: Тестирует обработку голосовых сообщений от получения файла до передачи транскрибированного текста.

#### Интеграционные тесты (`test/integration/`)

Эти тесты проверяют взаимодействие нескольких компонентов системы.

- `webhook.spec.ts`: Основной интеграционный тест, который:
  - Использует `supertest` для отправки настоящих HTTP-запросов на эндпоинт `/api/telegram/webhook/...`.
  - Проверяет валидацию секретного токена (`X-Telegram-Bot-Api-Secret-Token`).
  - Убеждается, что входящие сообщения корректно маршрутизируются к нужному обработчику в зависимости от типа (`/start`, обычный текст, голосовое сообщение).

---

## 2. Области для Улучшения и Недостающие Тесты

Хотя текущее покрытие является хорошей основой, есть несколько ключевых областей, где тестирование можно и нужно расширить.

### Тесты для AI Service Layer

Слой для работы с AI (`/server/services/ai`) полностью покрыт тестами.

- **`AIManager.ts`**: ✅ **Покрыто**
  - Проверяется корректное создание инстанса нужного провайдера (`OpenAIProvider` или `GeminiProvider`) в зависимости от `runtimeConfig.aiProvider`.
- **`ASRManager.ts`**: ✅ **Покрыто**
  - Проверяется корректное создание инстанса нужного провайдера для транскрипции в зависимости от `runtimeConfig.asrProvider`.
- **`providers/openai.ts`**: ✅ **Покрыто**
  - Проверяется, что конструктор выбрасывает ошибку, если API-ключ не предоставлен.
  - Тестируется `generateTextResponse` с различными сценариями (успех, пустой ответ, ошибки API).
  - Тестируется `transcribeAudio` с Whisper (успех, пустая транскрипция, ошибки API).
- **`providers/gemini.ts`**: ✅ **Покрыто**
  - Проверяется, что конструктор выбрасывает ошибку, если API-ключ не предоставлен.
  - Тестируется логика маппинга сообщений (`mapMessages`).
  - Тестируется `generateTextResponse` с различными сценариями.
  - Тестируется `transcribeAudio` с Google Cloud Speech-to-Text.

### Тесты для Планировщика Задач (Scheduler)

Сервис `schedulerService.ts` полностью покрыт тестами.

- **Что покрыто**: ✅ **Полное покрытие**
  1.  Тест с использованием `vi.useFakeTimers()` для управления временем.
  2.  Создание в тестовой БД сессии с истекшим `state_expires_at`.
  3.  Вызов основной функции планировщика.
  4.  Проверка, что были вызваны `telegramService.sendMessage`, `sessionService.setSessionState` и `telegramService.setBotCommands` с правильными аргументами.
  5.  Проверка, что сессии, у которых срок не истек, не были затронуты.

### Тесты для Голосовых Сообщений

Функциональность обработки голосовых сообщений полностью покрыта тестами.

- **`voiceHandler.spec.ts`**: ✅ **Полное покрытие**
  - Тестируется успешная обработка голосового сообщения (получение файла → скачивание → транскрипция → передача в текстовый обработчик).
  - Тестируется обработка сообщений без голосовых данных.
  - Тестируется обработка ошибок при получении информации о файле.
  - Тестируется обработка ошибок при скачивании файла.
  - Тестируется обработка ошибок при транскрипции.
- **`ai/openai.provider.spec.ts`**: ✅ **Покрыта транскрипция**
  - Тестируется успешная транскрипция через Whisper.
  - Тестируется транскрипция с указанием языка.
  - Тестируется обработка пустой транскрипции.
  - Тестируется обработка ошибок API.
- **`ai/gemini.provider.spec.ts`**: ✅ **Покрыта транскрипция**
  - Тестируется успешная транскрипция через Google Cloud Speech.
  - Тестируется транскрипция с указанием языка.
  - Тестируется обработка пустой транскрипции.
  - Тестируется обработка ошибок API.
- **`telegramService.spec.ts`**: ✅ **Покрыты файловые операции**
  - Тестируется `getFileInfo` (успех, ошибки, отсутствие токена).
  - Тестируется `downloadFile` (успех, ошибки скачивания).
- **Интеграционные тесты**: ✅ **Покрыта маршрутизация**
  - Тестируется корректная маршрутизация голосовых сообщений к `handleVoiceMessage`.

### Краевые случаи и обработка ошибок

- **`messageHandler.ts`**:
  - **Что нужно**: Протестировать логику истечения состояния `awaiting_prompt`. Что происходит, если пользователь отправляет сообщение ровно в момент истечения или после? (Частично это покроется тестами планировщика, но проверка в `messageHandler` также важна).
  - **Зачем**: Проверить корректность работы конечного автомата (state machine).
- **Общая отказоустойчивость**:
  - **Что нужно**: Добавить тесты, которые симулируют сбой базы данных. Что произойдет, если `getQuery` или `runQuery` выбросят исключение?
  - **Зачем**: Убедиться, что приложение корректно обрабатывает такие сбои, логирует ошибку и возвращает код ответа `500`, а не падает.

### Тесты для Утилит и Скриптов

- **`seedBots.ts`**:
  - **Что нужно**: Протестировать скрипт наполнения БД, мокируя `process.env`, чтобы проверить, что он корректно считывает переменные окружения и формирует `INSERT` запросы.
  - **Зачем**: Гарантировать, что процесс начальной конфигурации ботов работает правильно.

### End-to-End (E2E) Тесты

Это самый важный недостающий тип тестов. Они симулируют полный путь взаимодействия пользователя с системой.

- **Что нужно**: Создать E2E тест (`/test/e2e/`), который:
  1.  Запускает полный сервер Nuxt.
  2.  Эмулирует отправку вебхука с командой `/start`.
  3.  Эмулирует отправку `/setprompt`.
  4.  Эмулирует отправку текста для нового промпта.
  5.  Проверяет, что промпт сохранился в БД.
  6.  Эмулирует отправку обычного сообщения и проверяет, что в вызов AI (замоканный через MSW) передается правильный контекст (история + новый промпт).
  7.  Эмулирует вызов `/bots` и проверяет, что в ответе отображается настроенный бот.
- **Зачем**: Проверить, что все компоненты системы (API, сервисы, БД) работают вместе как единое целое, реализуя полный пользовательский сценарий.
